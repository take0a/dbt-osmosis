---
sidebar_position: 3
---
# 継承

## 概要

dbt-osmosis の最も強力な機能の一つは、**複数レベルの列ドキュメント継承**です。つまり、列の**すべての**関連タグ、説明、メタフィールドを、**任意の**上流ノードから現在のモデルに**カスケード**できます。

例えば、次のような場合です。

1. **ソース** `salesforce` が列 `contact_id` を定義し、詳細な説明とコンプライアンスタグ（例: `["GDPR", "PII"]`）が付与されているとします。
2. **ステージングモデル** が、この列に同じ列名（`contact_id`）のエイリアスを設定しますが、再定義は行いません。
3. 後続の**中間**モデルが、列名を変更したり変更したりすることなく、そのステージングモデルを参照します。

dbt-osmosis は、最終モデルの `contact_id` がソースからドキュメントを継承していることを検出できます。このアプローチにより、**DRY** ドキュメント（一度定義すれば、どこにでも渡せる）が実現されます。

## どのように動くか

### 1. 祖先ツリーの構築

dbt-osmosis は、特定のノード（モデル、シード、またはソース）を参照する際、まず上流のすべての依存関係（複数レベルの親を含む）を走査して **祖先ツリー** を構築します。具体的には以下のようになります。

- 一時的なノード（通常はドキュメント化されていないか、系統の一部ではない）は無視します。
- すべての **一意の** 祖先ノード（ソース、シード、またはモデル）を収集します。
- ノードに複数の祖先がある場合は、それらをすべて（直接の親だけでなく）含めます。

内部的には、これはコード内の `_build_node_ancestor_tree(...)` によって実行されます。結果は次のような構造になります。

```
{
  "generation_0": ["model.my_project.intermediate.my_node"],       # the current node
  "generation_1": ["model.my_project.staging.salesforce_contacts"],
  "generation_2": ["source.my_project.salesforce"]                 # the farthest removed ancestor
}
```

### 2. 「ナレッジグラフ」の集約

dbt-osmosis は、そのツリーを**逆順に** し、**最も古い**祖先（ソースノードなど）から開始して、ステージングノードや中間ノードを経由して**時間的に前方**に進みます。これにより、各ノードのドキュメントが最終的な子ノードに効果的に重ねられます。これは `_build_column_knowledge_graph(...)` によって処理され、以下の処理が行われます。

- 最終ノードの**すべての**列を調べます。
- 各祖先の列で一致するものを検索します。
- 子ノードのドキュメントが欠落しているかプレースホルダである場合、祖先からの説明、タグ、メタフィールド、その他の指定されたキーを子ノードのドキュメントに**マージ**します。
- エフェメラルノードをスキップし、その他のすべてのノードからマージします。

マージの際には、設定フラグが考慮されます。例: `--skip-merge-meta` または `--skip-add-tags` を使用します。子プロセスに既に**空でない**説明がある場合、上書きは行われません（`--force-inherit-descriptions` を使用した場合を除く）。子プロセスにプレースホルダしかない場合は、アップストリームのドキュメントに置き換えられます。

### 3. 名前変更とあいまい一致の処理

dbt-osmosis は、デフォルトでは列名が **完全** に一致することを前提としています。ただし、コードには以下の処理も含まれています。

- **FuzzyCaseMatching**: 大文字と小文字の差異を処理します。
- **FuzzyPrefixMatching**: 既知のプレフィックスを削除できます。例えば、ステージングモデルで `contact_id` を `stg_contact_id` に名前変更した場合でも、これらを同じ列として扱いたい場合などです。

将来的には、これらのフックがさらに拡張され、より高度なあいまい一致や特定のパターンの無視が可能になる可能性があります。また、独自の名前変更ルールを処理するプラグインを実装することもできます。

### 4. 子ノードの更新

最後に、「ナレッジグラフ」が構築されると、dbt-osmosis は子ノードの各列を更新します。このステップは `inherit_upstream_column_knowledge(...)` によって実行されます。子列に説明などのデータが欠落している場合は、上流の祖先から利用可能な最適なドキュメントが**入力**されます。

## 例

リネージのチェーンを想像してください:

```
source.salesforce → staging.salesforce_contacts → intermediate.int_contacts → marts.int_contacts_reporting
```

`source.salesforce` には次のように記述されているかもしれない:

```yaml
columns:
  - name: contact_id
    description: "Unique ID for each contact from Salesforce"
    tags: ["PII", "GDPR"]
  - name: email
    description: "Primary email address of the contact"
```

`staging.salesforce_contacts` では `contact_id` や `email` が再定義されていない可能性があります。そのため、dbt-osmosis はこれらを「継承」したものと認識します。その後、`intermediate.int_contacts` には `contact_id` がありますが、説明が「連絡先ID、毎日更新」に変更されます。そのため、`marts.int_contacts_reporting` に到達する頃には、新しい説明が優先されます。途中で削除または変更しない限り、元のコンプライアンスタグはそのまま保持されます。

## 列の相違する場合

ある時点で列名を変更したり、（上流で同じ名前を使用しながら）列の意味を大幅に変更したりした場合、dbt-osmosis は列を強制的に一致させることはありません。以下の方法があります。

- **手動で** 子のドキュメントを上書きして新しい意味を反映させる。
- 列を本当に区別したい場合は、別の名前を付けることで、新しい列名の継承をスキップする。
- あるいは、体系的にプレフィックスを付けつつもドキュメントを下位に継承したい場合は、ファジープレフィックスロジックを活用する。

## 継承を制御する設定フラグ

ドキュメントマージの程度を調整するための関連フラグをいくつか紹介します。

- `--skip-merge-meta`: 親ノードからの `meta` フィールドの継承をスキップします。
- `--skip-add-tags`: アップストリームからのタグの継承をスキップします。
- `--force-inherit-descriptions`: 子ノードの既存の（ただしプレースホルダの可能性がある）説明を親ノードのドキュメントで上書きします。
- `--add-progenitor-to-meta`: 各列に `meta.osmosis_progenitor` フィールドを追加して、*どの*ノードから継承されたかを確認します。
- `--add-inheritance-for-specified-keys=policy_tags` (など): アップストリームドキュメントから追加のカスタムフィールドを継承します。

## 主なメリット

- **重複ドキュメントの排除**: ソース（または最初のステージング）で列を一度ドキュメント化すれば、下流のすべてで再利用できます。
- **コンプライアンスタグの伝播**: 特定の列に「GDPR」または「PII」タグが付加されている場合、パイプライン全体でその列にタグが適用されます。
- **一貫性の向上**: 「同じフィールドに異なる説明」がなくなる。
- **拡張可能**: 命名パターンが複雑な場合は、独自のあいまい一致ロジックを作成できます。

## 今後の機能強化

- **堅牢なあいまい一致**: 列名の一致を拡張し、より多くのパターンや部分的な名前変更に対応します。
- **外部データ辞書**: 列のCSVまたはJSON辞書を取り込み、上流ノードであるかのようにドキュメントを作成します。
- **LLMとの統合**: ナレッジグラフとLLMを組み合わせることで、ドキュメントが存在しない列のドキュメントを自動的に作成します。**dbt-osmosis**は既にOpenAI用の`--synthesize`をサポートしていますが、より深い統合も可能です。
- **共通プレフィックスの無視**: 例えば、子と親の間で列をリンクする際に「stg_」や「dim_」を無視します。

---

### まとめ

**複数レベルの列継承** は、dbt-osmosis の中心的な機能であり、重複したドキュメント作成を大幅に削減します。dbt-osmosis は、上流ノードすべてからナレッジグラフを構築することで、各モデルまたはソースのすべての列について可能な限り完全なドキュメントを取得し、必要に応じて特定のマージをオーバーライドまたはスキップできるようにします。コンプライアンスタグを統一したり、説明を継承したり、系統の大部分を統一したりする場合でも、**継承** は、重複することなくドキュメントの一貫性を維持する方法です。.
